"""
Renewra Oracle Service - Solana NAV Submission

Submits computed NAV values to the on-chain oracle account.
Runs continuously, submitting NAV updates at configured intervals.
"""

import asyncio
import base58
import json
import logging
import os
import struct
import sys
import time
from pathlib import Path
from typing import Optional, Tuple

# Solana SDK imports
try:
    from solders.keypair import Keypair
    from solders.pubkey import Pubkey
    from solders.system_program import ID as SYSTEM_PROGRAM_ID
    from solders.instruction import Instruction, AccountMeta
    from solders.transaction import Transaction
    from solders.message import Message
    from solders.hash import Hash
except ImportError:
    print("ERROR: solders library not installed. Run: pip install solders")
    sys.exit(1)

try:
    import httpx
except ImportError:
    print("ERROR: httpx library not installed. Run: pip install httpx")
    sys.exit(1)

from nav_engine import NavEngine

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


class OracleService:
    """
    Oracle Service for submitting NAV updates to Solana.
    
    Responsibilities:
    - Compute NAV using NavEngine
    - Build and sign submit_nav transactions
    - Submit to Solana devnet
    - Handle errors and retries
    - Run continuous submission loop
    """
    
    # Anchor instruction discriminator for submit_nav
    # Generated by: sha256("global:submit_nav")[0:8]
    SUBMIT_NAV_DISCRIMINATOR = bytes([132, 186, 250, 155, 121, 127, 246, 0])
    
    def __init__(
        self,
        program_id: str,
        oracle_keypair_path: str,
        governance_pda: Optional[str] = None,
        nav_oracle_pda: Optional[str] = None,
        rpc_url: str = "https://api.devnet.solana.com",
        projects_file: str = "oracle/projects.json"
    ):
        """
        Initialize the Oracle Service.
        
        Args:
            program_id: Deployed Solana program ID
            oracle_keypair_path: Path to oracle keypair JSON file
            governance_pda: Optional pre-computed governance PDA address
            nav_oracle_pda: Optional pre-computed nav_oracle PDA address
            rpc_url: Solana RPC endpoint URL
            projects_file: Path to projects.json for NAV computation
        """
        # Parse program ID
        self.program_id = Pubkey.from_string(program_id)
        logger.info(f"Program ID: {self.program_id}")
        
        # Load oracle keypair
        self.oracle_keypair = self._load_keypair(oracle_keypair_path)
        logger.info(f"Oracle Pubkey: {self.oracle_keypair.pubkey()}")
        
        # RPC client setup
        self.rpc_url = rpc_url
        self.client = httpx.AsyncClient(timeout=30.0)
        logger.info(f"RPC URL: {rpc_url}")
        
        # Derive PDAs
        self.governance_pda = self._derive_or_use_pda(
            governance_pda, b"governance"
        )
        self.nav_oracle_pda = self._derive_or_use_pda(
            nav_oracle_pda, b"nav_oracle"
        )
        logger.info(f"Governance PDA: {self.governance_pda}")
        logger.info(f"NAV Oracle PDA: {self.nav_oracle_pda}")
        
        # Initialize NAV engine
        self.nav_engine = NavEngine(projects_file)
        logger.info(f"NAV Engine loaded with {len(self.nav_engine.projects)} projects")
        
        # Stats tracking
        self.submission_count = 0
        self.last_submission_time = 0
        self.last_nav = 0
    
    def _load_keypair(self, keypair_path: str) -> Keypair:
        """Load a Solana keypair from a JSON file."""
        path = Path(keypair_path)
        if not path.exists():
            raise FileNotFoundError(f"Keypair file not found: {keypair_path}")
        
        with open(path, 'r') as f:
            secret_key = json.load(f)
        
        # Keypair JSON is an array of bytes
        return Keypair.from_bytes(bytes(secret_key))
    
    def _derive_or_use_pda(
        self, 
        provided_pda: Optional[str], 
        seed: bytes
    ) -> Pubkey:
        """Derive a PDA or use the provided address."""
        if provided_pda:
            return Pubkey.from_string(provided_pda)
        
        # Derive PDA from seed
        pda, bump = Pubkey.find_program_address([seed], self.program_id)
        return pda
    
    async def _get_latest_blockhash(self) -> Hash:
        """Get the latest blockhash from the network."""
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getLatestBlockhash",
            "params": [{"commitment": "finalized"}]
        }
        
        response = await self.client.post(self.rpc_url, json=payload)
        result = response.json()
        
        if "error" in result:
            raise Exception(f"RPC error: {result['error']}")
        
        blockhash_str = result["result"]["value"]["blockhash"]
        return Hash.from_string(blockhash_str)
    
    async def _send_transaction(self, signed_tx: Transaction) -> str:
        """Send a signed transaction to the network."""
        # Serialize the transaction
        tx_bytes = bytes(signed_tx)
        tx_base64 = base58.b58encode(tx_bytes).decode('utf-8')
        
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "sendTransaction",
            "params": [
                tx_base64,
                {
                    "encoding": "base58",
                    "skipPreflight": False,
                    "preflightCommitment": "confirmed"
                }
            ]
        }
        
        response = await self.client.post(self.rpc_url, json=payload)
        result = response.json()
        
        if "error" in result:
            error_msg = result["error"].get("message", str(result["error"]))
            raise Exception(f"Transaction failed: {error_msg}")
        
        return result["result"]
    
    async def _get_account_info(self, pubkey: Pubkey) -> Optional[dict]:
        """Get account info from the network."""
        payload = {
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getAccountInfo",
            "params": [
                str(pubkey),
                {"encoding": "base64", "commitment": "confirmed"}
            ]
        }
        
        response = await self.client.post(self.rpc_url, json=payload)
        result = response.json()
        
        if "error" in result:
            return None
        
        return result.get("result", {}).get("value")
    
    def _build_submit_nav_instruction(self, nav_in_cents: int) -> Instruction:
        """
        Build the submit_nav instruction.
        
        Accounts required:
        1. oracle_signer (signer) - Oracle keypair
        2. governance (readonly) - Governance PDA
        3. nav_oracle (writable) - NAV Oracle PDA
        
        Data: 8-byte discriminator + 8-byte u64 nav
        """
        # Build instruction data
        # Discriminator (8 bytes) + nav_in_cents (u64, 8 bytes little-endian)
        data = self.SUBMIT_NAV_DISCRIMINATOR + struct.pack('<Q', nav_in_cents)
        
        # Build account metas
        accounts = [
            AccountMeta(pubkey=self.oracle_keypair.pubkey(), is_signer=True, is_writable=False),
            AccountMeta(pubkey=self.governance_pda, is_signer=False, is_writable=False),
            AccountMeta(pubkey=self.nav_oracle_pda, is_signer=False, is_writable=True),
        ]
        
        return Instruction(
            program_id=self.program_id,
            accounts=accounts,
            data=data
        )
    
    async def submit_nav(self, nav_in_cents: int) -> str:
        """
        Submit a NAV update to the Solana program.
        
        Args:
            nav_in_cents: NAV value in cents (e.g., 4760 = $47.60)
            
        Returns:
            Transaction signature string
        """
        logger.info(f"Building submit_nav transaction for NAV: {nav_in_cents} cents (${nav_in_cents/100:.2f})")
        
        # Build instruction
        instruction = self._build_submit_nav_instruction(nav_in_cents)
        
        # Get latest blockhash
        blockhash = await self._get_latest_blockhash()
        
        # Build message
        message = Message.new_with_blockhash(
            [instruction],
            self.oracle_keypair.pubkey(),
            blockhash
        )
        
        # Sign transaction
        tx = Transaction.new_unsigned(message)
        tx.sign([self.oracle_keypair], blockhash)
        
        # Send transaction
        signature = await self._send_transaction(tx)
        
        logger.info(f"Submitted NAV, signature: {signature}")
        return signature
    
    async def verify_nav_on_chain(self) -> Optional[int]:
        """
        Read the current NAV value from the on-chain oracle account.
        
        Returns:
            NAV in cents if readable, None otherwise
        """
        account_info = await self._get_account_info(self.nav_oracle_pda)
        
        if not account_info or not account_info.get('data'):
            logger.warning("NAV Oracle account not found or empty")
            return None
        
        # Decode base64 data
        import base64
        data = base64.b64decode(account_info['data'][0])
        
        # NavOracle structure:
        # 8 bytes discriminator
        # 8 bytes latest_nav (u64)
        # 8 bytes previous_nav (u64)
        # 8 bytes timestamp (i64)
        # 1 byte bump
        if len(data) < 33:
            logger.warning(f"NAV Oracle data too short: {len(data)} bytes")
            return None
        
        latest_nav = struct.unpack('<Q', data[8:16])[0]
        previous_nav = struct.unpack('<Q', data[16:24])[0]
        timestamp = struct.unpack('<q', data[24:32])[0]
        
        logger.debug(f"On-chain NAV: {latest_nav} cents, previous: {previous_nav}, timestamp: {timestamp}")
        return latest_nav
    
    async def run_oracle_loop(
        self,
        interval_seconds: int = 3600,
        simulate_monthly: bool = True
    ):
        """
        Run the continuous oracle submission loop.
        
        Args:
            interval_seconds: Time between NAV submissions (default: 1 hour)
            simulate_monthly: Whether to run monthly simulation each cycle
        """
        logger.info(f"Starting oracle loop with {interval_seconds}s interval")
        logger.info("Press Ctrl+C to stop")
        
        while True:
            try:
                # Run monthly simulation if enabled
                if simulate_monthly:
                    result = self.nav_engine.simulate_monthly_yield()
                    logger.info(f"Simulated monthly yield for {result['projects_simulated']} projects")
                
                # Compute NAV
                nav_cents, timestamp = self.nav_engine.compute_nav()
                logger.info(f"Computed NAV: {nav_cents} cents (${nav_cents/100:.2f})")
                
                # Submit NAV
                signature = await self.submit_nav(nav_cents)
                
                # Update stats
                self.submission_count += 1
                self.last_submission_time = time.time()
                self.last_nav = nav_cents
                
                # Verify on-chain (optional)
                await asyncio.sleep(5)  # Wait for confirmation
                on_chain_nav = await self.verify_nav_on_chain()
                if on_chain_nav:
                    logger.info(f"Verified on-chain NAV: {on_chain_nav} cents")
                
                # Log stats
                logger.info(
                    f"Stats: submissions={self.submission_count}, "
                    f"last_nav={self.last_nav} cents"
                )
                
                # Wait for next interval
                logger.info(f"Sleeping for {interval_seconds}s until next submission...")
                await asyncio.sleep(interval_seconds)
                
            except KeyboardInterrupt:
                logger.info("Oracle loop stopped by user")
                break
                
            except Exception as e:
                logger.error(f"Error in oracle loop: {e}")
                logger.info("Retrying in 60s...")
                await asyncio.sleep(60)
    
    async def submit_once(self) -> Tuple[int, str]:
        """
        Compute and submit NAV once (for testing).
        
        Returns:
            Tuple of (nav_in_cents, signature)
        """
        nav_cents, timestamp = self.nav_engine.compute_nav()
        signature = await self.submit_nav(nav_cents)
        return nav_cents, signature
    
    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()


async def main():
    """CLI entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Renewra Oracle Service')
    parser.add_argument(
        '--program-id',
        default=os.environ.get('RENEWRA_PROGRAM_ID', '5nU2nHv2Pw9bWWL2BsTotX6mDaP1fTj1EZ7JMXAe6T5Z'),
        help='Solana program ID'
    )
    parser.add_argument(
        '--keypair',
        default=os.environ.get('ORACLE_KEYPAIR_PATH', 'oracle/oracle-keypair.json'),
        help='Path to oracle keypair JSON file'
    )
    parser.add_argument(
        '--rpc-url',
        default=os.environ.get('SOLANA_RPC_URL', 'https://api.devnet.solana.com'),
        help='Solana RPC endpoint URL'
    )
    parser.add_argument(
        '--projects',
        default='oracle/projects.json',
        help='Path to projects JSON file'
    )
    parser.add_argument(
        '--interval',
        type=int,
        default=3600,
        help='Submission interval in seconds (default: 3600 = 1 hour)'
    )
    parser.add_argument(
        '--once',
        action='store_true',
        help='Submit NAV once and exit (for testing)'
    )
    parser.add_argument(
        '--verify-only',
        action='store_true',
        help='Only verify on-chain NAV, do not submit'
    )
    parser.add_argument(
        '--no-simulate',
        action='store_true',
        help='Disable monthly yield simulation'
    )
    
    args = parser.parse_args()
    
    # Create service
    try:
        service = OracleService(
            program_id=args.program_id,
            oracle_keypair_path=args.keypair,
            rpc_url=args.rpc_url,
            projects_file=args.projects
        )
    except FileNotFoundError as e:
        logger.error(f"Configuration error: {e}")
        logger.info("Create an oracle keypair with: solana-keygen new -o oracle/oracle-keypair.json")
        sys.exit(1)
    
    try:
        if args.verify_only:
            nav = await service.verify_nav_on_chain()
            if nav:
                print(f"On-chain NAV: {nav} cents (${nav/100:.2f})")
            else:
                print("Could not read NAV from chain")
                
        elif args.once:
            nav, sig = await service.submit_once()
            print(f"Submitted NAV: {nav} cents (${nav/100:.2f})")
            print(f"Signature: {sig}")
            print(f"Explorer: https://explorer.solana.com/tx/{sig}?cluster=devnet")
            
        else:
            await service.run_oracle_loop(
                interval_seconds=args.interval,
                simulate_monthly=not args.no_simulate
            )
            
    finally:
        await service.close()


if __name__ == '__main__':
    asyncio.run(main())
